# Architect Solution Validation Checklist （架构师解决方案验证检查清单）

此检查清单作为架构师在开发执行前验证技术设计和架构的综合框架。架构师应系统地处理每个项目，确保架构健壮、可扩展、安全，并与产品需求保持一致。

[[LLM: 初始化指令 - 必需工件

在继续此检查清单之前，确保您有权访问：

1. architecture.md - 主要架构文档（检查docs/architecture.md）
2. prd.md - 产品需求文档，用于需求对齐（检查docs/prd.md）
3. frontend-architecture.md或fe-architecture.md - 如果这是UI项目（检查docs/frontend-architecture.md）
4. 架构中引用的任何系统图
5. API文档（如果有）
6. 技术栈详情和版本规范

重要：如果任何必需文档缺失或无法访问，在继续之前立即询问用户其位置或内容。

项目类型检测：
首先，通过检查确定项目类型：

- 架构是否包含前端/UI组件？
- 是否有frontend-architecture.md文档？
- PRD是否提及用户界面或前端需求？

如果这是仅后端或仅服务项目：

- 跳过标记为[[FRONTEND ONLY]]的部分
- 特别关注API设计、服务架构和集成模式
- 在最终报告中注明由于项目类型跳过了前端部分

验证方法：
对于每个部分，您必须：

1. 深度分析 - 不要只是勾选框，根据提供的文档彻底分析每个项目
2. 基于证据 - 验证时引用文档的具体部分或引用
3. 批判性思维 - 质疑假设并识别差距，而不仅仅是确认存在的内容
4. 风险评估 - 考虑每个架构决策可能出现的问题

执行模式：
询问用户是否希望逐步完成检查清单：

- 逐节进行（交互模式）- 审查每个部分，呈现发现，在继续前获得确认
- 一次性完成（综合模式）- 完成完整分析并在最后呈现综合报告]]

## 1. REQUIREMENTS ALIGNMENT （需求对齐）

[[LLM: 在评估此部分之前，花点时间从PRD中完全理解产品的目的和目标。正在解决的核心问题是什么？用户是谁？关键成功因素是什么？在验证对齐时记住这些。对于每个项目，不要只是检查是否提及 - 验证架构提供了具体的技术解决方案。]]

### 1.1 Functional Requirements Coverage （功能需求覆盖）

- [ ] 架构支持PRD中的所有功能需求
- [ ] 解决了所有epics和stories的技术方法
- [ ] 考虑了边缘情况和性能场景
- [ ] 考虑了所有必需的集成
- [ ] 技术架构支持用户旅程

### 1.2 Non-Functional Requirements Alignment （非功能需求对齐）

- [ ] 用具体解决方案解决性能需求
- [ ] 用方法记录可扩展性考虑因素
- [ ] 安全需求有相应的技术控制
- [ ] 定义了可靠性和弹性方法
- [ ] 合规需求有技术实施

### 1.3 Technical Constraints Adherence （技术约束遵循）

- [ ] 满足PRD中的所有技术约束
- [ ] 遵循平台/语言要求
- [ ] 适应基础设施约束
- [ ] 解决第三方服务约束
- [ ] 遵循组织技术标准

## 2. ARCHITECTURE FUNDAMENTALS （架构基础）

[[LLM: 架构清晰度对成功实施至关重要。在审查此部分时，想象您正在向新开发人员解释系统。是否有任何可能导致误解的歧义？AI代理是否能够实施此架构而不混淆？寻找具体的图表、组件定义和清晰的交互模式。]]

### 2.1 Architecture Clarity （架构清晰度）

- [ ] 用清晰的图表记录架构
- [ ] 定义主要组件及其职责
- [ ] 映射组件交互和依赖项
- [ ] 清晰说明数据流
- [ ] 指定每个组件的技术选择

### 2.2 Separation of Concerns （关注点分离）

- [ ] UI、业务逻辑和数据层之间的清晰边界
- [ ] 组件之间的职责清晰划分
- [ ] 组件之间的接口定义良好
- [ ] 组件遵循单一职责原则
- [ ] 适当解决横切关注点（日志记录、身份验证等）

### 2.3 Design Patterns & Best Practices （设计模式和最佳实践）

- [ ] 采用适当的设计模式
- [ ] 遵循行业最佳实践
- [ ] 避免反模式
- [ ] 整个架构风格一致
- [ ] 记录和解释模式使用

### 2.4 Modularity & Maintainability （模块化和可维护性）

- [ ] 系统分为内聚、松耦合的模块
- [ ] 组件可以独立开发和测试
- [ ] 更改可以本地化到特定组件
- [ ] 代码组织促进可发现性
- [ ] 架构专门为AI代理实施设计

## 3. TECHNICAL STACK & DECISIONS （技术栈和决策）

[[LLM: 技术选择有长期影响。对于每个技术决策，考虑：这是可能工作的最简单解决方案吗？我们是否过度工程化？这会扩展吗？维护影响是什么？选定版本中是否有安全漏洞？验证定义了具体版本，而不是范围。]]

### 3.1 Technology Selection （技术选择）

- [ ] 选定的技术满足所有需求
- [ ] 具体定义技术版本（不是范围）
- [ ] 用明确的理由证明技术选择
- [ ] 记录考虑的替代方案及其优缺点
- [ ] 选定的栈组件良好协作

### 3.2 Frontend Architecture （前端架构） [[FRONTEND ONLY]]

[[LLM: 如果这是仅后端或仅服务项目，跳过整个部分。仅当项目包含用户界面时评估。]]

- [ ] 具体选择UI框架和库
- [ ] 定义状态管理方法
- [ ] 指定组件结构和组织
- [ ] 概述响应式/自适应设计方法
- [ ] 确定构建和打包策略

### 3.3 Backend Architecture （后端架构）

- [ ] 定义API设计和标准
- [ ] 服务组织和边界清晰
- [ ] 指定身份验证和授权方法
- [ ] 概述错误处理策略
- [ ] 定义后端扩展方法

### 3.4 Data Architecture （数据架构）

- [ ] 完全定义数据模型
- [ ] 选择数据库技术并说明理由
- [ ] 记录数据访问模式
- [ ] 指定数据迁移/种子方法
- [ ] 概述数据备份和恢复策略

## 4. FRONTEND DESIGN & IMPLEMENTATION （前端设计和实施） [[FRONTEND ONLY]]

[[LLM: 对于仅后端项目，应跳过整个部分。仅当项目包含用户界面时评估。评估时，确保主架构文档和前端特定架构文档之间的一致性。]]

### 4.1 Frontend Philosophy & Patterns （前端理念和模式）

- [ ] 框架和核心库与主架构文档对齐
- [ ] 清晰描述组件架构（例如，原子设计）
- [ ] 状态管理策略适合应用程序复杂性
- [ ] 数据流模式一致且清晰
- [ ] 定义样式方法并指定工具

### 4.2 Frontend Structure & Organization （前端结构和组织）

- [ ] 用ASCII图清晰记录目录结构
- [ ] 组件组织遵循既定模式
- [ ] 文件命名约定明确
- [ ] 结构支持选定框架的最佳实践
- [ ] 关于新组件应放置位置的明确指导

### 4.3 Component Design （组件设计）

- [ ] 定义组件模板/规范格式
- [ ] 良好记录组件props、状态和事件
- [ ] 识别共享/基础组件
- [ ] 建立组件可重用性模式
- [ ] 将可访问性要求内置到组件设计中

### 4.4 Frontend-Backend Integration （前端-后端集成）

- [ ] 明确定义API交互层
- [ ] 记录HTTP客户端设置和配置
- [ ] API调用的错误处理全面
- [ ] 服务定义遵循一致模式
- [ ] 与后端的身份验证集成清晰

### 4.5 Routing & Navigation （路由和导航）

- [ ] 指定路由策略和库
- [ ] 路由定义表全面
- [ ] 定义路由保护机制
- [ ] 解决深度链接考虑因素
- [ ] 导航模式一致

### 4.6 Frontend Performance （前端性能）

- [ ] 定义图像优化策略
- [ ] 记录代码分割方法
- [ ] 建立懒加载模式
- [ ] 指定重新渲染优化技术
- [ ] 定义性能监控方法

## 5. RESILIENCE & OPERATIONAL READINESS （弹性和运营准备度）

[[LLM: 生产系统以意外方式失败。在审查此部分时，考虑墨菲定律 - 什么可能出错？考虑现实场景：峰值负载期间会发生什么？当关键服务关闭时系统如何行为？运营团队能否在凌晨3点诊断问题？寻找具体的弹性模式，而不仅仅是"错误处理"的提及。]]

### 5.1 Error Handling & Resilience （错误处理和弹性）

- [ ] 错误处理策略全面
- [ ] 在适当时定义重试策略
- [ ] 为关键服务指定断路器或回退
- [ ] 定义优雅降级方法
- [ ] 系统可以从部分故障中恢复

### 5.2 Monitoring & Observability （监控和可观测性）

- [ ] 定义日志记录策略
- [ ] 指定监控方法
- [ ] 识别系统健康的关键指标
- [ ] 概述警报阈值和策略
- [ ] 内置调试和故障排除功能

### 5.3 Performance & Scaling （性能和扩展）

- [ ] 识别并解决性能瓶颈
- [ ] 在适当时定义缓存策略
- [ ] 指定负载平衡方法
- [ ] 概述水平和垂直扩展策略
- [ ] 提供资源大小建议

### 5.4 Deployment & DevOps （部署和DevOps）

- [ ] 定义部署策略
- [ ] 概述CI/CD管道方法
- [ ] 指定环境策略（开发、暂存、生产）
- [ ] 定义基础设施即代码方法
- [ ] 概述回滚和恢复程序

## 6. SECURITY & COMPLIANCE （安全和合规）

[[LLM: 安全不是可选的。以黑客的心态审查此部分 - 有人如何利用此系统？还要考虑合规：是否有适用的行业特定法规？GDPR？HIPAA？PCI？确保架构主动解决这些问题。寻找具体的安全控制，而不仅仅是一般性陈述。]]

### 6.1 Authentication & Authorization （身份验证和授权）

- [ ] 明确定义身份验证机制
- [ ] 指定授权模型
- [ ] 如果需要，概述基于角色的访问控制
- [ ] 定义会话管理方法
- [ ] 解决凭据管理

### 6.2 Data Security （数据安全）

- [ ] 指定数据加密方法（静态和传输中）
- [ ] 定义敏感数据处理程序
- [ ] 概述数据保留和清除策略
- [ ] 如果需要，解决备份加密
- [ ] 如果需要，指定数据访问审计跟踪

### 6.3 API & Service Security （API和服务安全）

- [ ] 定义API安全控制
- [ ] 指定速率限制和节流方法
- [ ] 概述输入验证策略
- [ ] 解决CSRF/XSS预防措施
- [ ] 指定安全通信协议

### 6.4 Infrastructure Security （基础设施安全）

- [ ] 概述网络安全设计
- [ ] 指定防火墙和安全组配置
- [ ] 定义服务隔离方法
- [ ] 应用最小权限原则
- [ ] 概述安全监控策略

## 7. IMPLEMENTATION GUIDANCE （实施指导）

[[LLM: 清晰的实施指导防止代价高昂的错误。在审查此部分时，想象您是第一天开始的开发人员。他们是否有提高生产力所需的一切？编码标准是否足够清晰以保持团队一致性？寻找具体示例和模式。]]

### 7.1 Coding Standards & Practices （编码标准和实践）

- [ ] 定义编码标准
- [ ] 指定文档要求
- [ ] 概述测试期望
- [ ] 定义代码组织原则
- [ ] 指定命名约定

### 7.2 Testing Strategy （测试策略）

- [ ] 定义单元测试方法
- [ ] 概述集成测试策略
- [ ] 指定E2E测试方法
- [ ] 概述性能测试要求
- [ ] 定义安全测试方法

### 7.3 Frontend Testing （前端测试） [[FRONTEND ONLY]]

[[LLM: 对于仅后端项目跳过此子部分。]]

- [ ] 定义组件测试范围和工具
- [ ] 指定UI集成测试方法
- [ ] 考虑视觉回归测试
- [ ] 识别可访问性测试工具
- [ ] 解决前端特定的测试数据管理

### 7.4 Development Environment （开发环境）

- [ ] 记录本地开发环境设置
- [ ] 指定必需的工具和配置
- [ ] 概述开发工作流
- [ ] 定义源代码控制实践
- [ ] 指定依赖项管理方法

### 7.5 Technical Documentation （技术文档）

- [ ] 定义API文档标准
- [ ] 指定架构文档要求
- [ ] 概述代码文档期望
- [ ] 包含系统图和可视化
- [ ] 包含关键选择的决策记录

## 8. DEPENDENCY & INTEGRATION MANAGEMENT （依赖项和集成管理）

[[LLM: 依赖项通常是生产问题的来源。对于每个依赖项，考虑：如果它不可用会发生什么？是否有带安全补丁的更新版本？我们是否被锁定在供应商中？我们的应急计划是什么？验证具体版本和回退策略。]]

### 8.1 External Dependencies （外部依赖项）

- [ ] 识别所有外部依赖项
- [ ] 定义依赖项的版本策略
- [ ] 指定关键依赖项的回退方法
- [ ] 解决许可影响
- [ ] 概述更新和修补策略

### 8.2 Internal Dependencies （内部依赖项）

- [ ] 清晰映射组件依赖项
- [ ] 解决构建顺序依赖项
- [ ] 识别共享服务和工具
- [ ] 消除循环依赖项
- [ ] 定义内部组件的版本策略

### 8.3 Third-Party Integrations （第三方集成）

- [ ] 识别所有第三方集成
- [ ] 定义集成方法
- [ ] 解决与第三方的身份验证
- [ ] 指定集成故障的错误处理
- [ ] 考虑速率限制和配额

## 9. AI AGENT IMPLEMENTATION SUITABILITY （AI代理实施适用性）

[[LLM: 此架构可能由AI代理实施。以极端清晰度审查。模式是否一致？复杂性是否最小化？AI代理是否会做出错误假设？记住：明确比隐含更好。寻找清晰的文件结构、命名约定和实施模式。]]

### 9.1 Modularity for AI Agents （AI代理的模块化）

- [ ] 组件大小适合AI代理实施
- [ ] 最小化组件之间的依赖项
- [ ] 定义组件之间的清晰接口
- [ ] 组件具有单一、明确定义的职责
- [ ] 文件和代码组织针对AI代理理解优化

### 9.2 Clarity & Predictability （清晰度和可预测性）

- [ ] 模式一致且可预测
- [ ] 复杂逻辑分解为更简单的步骤
- [ ] 架构避免过于聪明或晦涩的方法
- [ ] 为不熟悉的模式提供示例
- [ ] 组件职责明确且清晰

### 9.3 Implementation Guidance （实施指导）

- [ ] 提供详细的实施指导
- [ ] 定义代码结构模板
- [ ] 记录具体的实施模式
- [ ] 识别常见陷阱并提供解决方案
- [ ] 在有用时提供类似实施的引用

### 9.4 Error Prevention & Handling （错误预防和处理）

- [ ] 设计减少实施错误的机会
- [ ] 定义验证和错误检查方法
- [ ] 在可能时纳入自愈机制
- [ ] 明确定义测试模式
- [ ] 提供调试指导

## 10. ACCESSIBILITY IMPLEMENTATION （可访问性实施） [[FRONTEND ONLY]]

[[LLM: 对于仅后端项目跳过此部分。可访问性是任何用户界面的核心要求。]]

### 10.1 Accessibility Standards （可访问性标准）

- [ ] 强调语义HTML使用
- [ ] 提供ARIA实施指南
- [ ] 定义键盘导航要求
- [ ] 指定焦点管理方法
- [ ] 解决屏幕阅读器兼容性

### 10.2 Accessibility Testing （可访问性测试）

- [ ] 识别可访问性测试工具
- [ ] 将测试过程集成到工作流中
- [ ] 指定合规目标（WCAG级别）
- [ ] 定义手动测试程序
- [ ] 概述自动化测试方法

[[LLM: 最终验证报告生成

现在您已完成检查清单，生成包含以下内容的综合验证报告：

1. 执行摘要
    - 整体架构准备度（高/中/低）
    - 识别的关键风险
    - 架构的关键优势
    - 项目类型（全栈/前端/后端）和评估的部分

2. 部分分析
    - 每个主要部分的通过率（通过项目的百分比）
    - 最令人担忧的失败或差距
    - 需要立即关注的部分
    - 注意由于项目类型跳过的任何部分

3. 风险评估
    - 按严重程度排序的前5个风险
    - 每个风险的缓解建议
    - 解决问题的时间表影响

4. 建议
    - 开发前必须修复的项目
    - 为提高质量应该修复的项目
    - 锦上添花的改进

5. AI实施准备度
    - AI代理实施的具体担忧
    - 需要额外澄清的区域
    - 需要解决的复杂性热点

6. 前端特定评估（如果适用）
    - 前端架构完整性
    - 主架构和前端架构文档之间的一致性
    - UI/UX规范覆盖
    - 组件设计清晰度

呈现报告后，询问用户是否希望详细分析任何特定部分，特别是那些有警告或失败的部分。]]
